# 一、object
## 1.1 创建
- 对象字面量（Object Literal）：
这是最简单的创建对象的方式，可以直接使用花括号 {} 创建一个对象，并通过属性和值的键值对来定义对象的属性和方法
```
const person = {
  name: 'John',
  age: 30,
  sayHello: function() {
    console.log('Hello!');
  }
};
```
- 构造函数（Constructor）：
可以使用构造函数创建一个对象，使用 new 关键字调用构造函数来创建对象的实例。构造函数内可以定义对象的属性和方法。
```
function Person(name, age) {
  this.name = name;
  this.age = age;
  this.sayHello = function() {
    console.log('Hello!');
  };
}

const person = new Person('John', 30);
```
- Object.create() 方法：
可以使用 Object.create() 方法创建一个新对象，并指定新对象的原型对象。原型对象可以包含对象的属性和方法。
```
const personPrototype = {
  sayHello: function() {
    console.log('Hello!');
  }
};

const person = Object.create(personPrototype);
person.name = 'John';
person.age = 30;

```
- 类（ES6+）：
可以使用类（class）来创建对象，并定义类的构造函数、属性和方法。类的实例化使用 new 关键字。
```
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  sayHello() {
    console.log('Hello!');
  }
}

const person = new Person('John', 30);
```
## 1.2 属性查询
- 点记法（Dot Notation）：
使用点号 . 后接属性名的方式，可以直接从对象上查询指定的属性。适用于属性名是有效的标识符的情况。
```
const person = {
  name: 'John',
  age: 30
};

const name = person.name; // 'John'
const age = person.age; // 30
```

- 方括号记法（Bracket Notation）：
使用方括号 [] 内包裹属性名的方式，可以从对象上查询指定的属性。适用于属性名包含特殊字符、动态生成的情况,方括号内应为字符串。
```
const person = {
  'first name': 'John',
  age: 30
};

const firstName = person['first name']; // 'John'
const age = person['age']; // 30
```

- Object.keys() 方法：
当想获取对象中所有可枚举属性的名称时，可以使用 Object.keys() 方法返回一个包含对象自身的所有属性名的数组。可以进一步处理这个数组来查询特定的属性。
```
const person = {
  name: 'John',
  age: 30
};
const keys = Object.keys(person); // ['name', 'age']
const name = person[keys[0]]; // 'John'
const age = person[keys[1]]; // 30
```

- Object.values(obj)：返回一个包含对象所有可枚举属性的值的数组。
示例代码：
```
const obj = {
  name: 'John',
  age: 25
};
const values = Object.values(obj);
console.log(values); // 输出：['John', 25]
```

- Object.entries(obj)：返回一个包含对象所有可枚举属性的键值对数组。
示例代码：
```
const obj = {
  name: 'John',
  age: 25
};
const entries = Object.entries(obj);
console.log(entries); // 输出：[['name', 'John'], ['age', 25]]
```

- in 操作符：
使用 in 操作符可以检查对象中是否存在指定的属性，返回布尔值结果。
```
const person = {
  name: 'John',
  age: 30
};
const hasName = 'name' in person; // true
const hasGender = 'gender' in person; // false
```

- hasOwnProperty() 方法：
使用 hasOwnProperty() 方法可以检查对象是否具有指定的属性。该方法只会检查对象自身是否拥有该属性，不会检查原型链上的属性。
```
const person = {
  name: 'John',
  age: 30
};
const hasName = person.hasOwnProperty('name'); // true
const hasGender = person.hasOwnProperty('gender'); // false
```

- Object.getOwnPropertyNames() 方法：
Object.getOwnPropertyNames() 方法返回一个数组，包含对象自身的所有属性（包括不可枚举属性,不包括symbol属性）的名称。可以进一步处理这个数组来查询特定的属性。
```
const person = {
  name: 'John',
  age: 30
};
const propertyNames = Object.getOwnPropertyNames(person); // ['name', 'age']
const name = person[propertyNames[0]]; // 'John'
const age = person[propertyNames[1]]; // 30
```

- Reflect.ownKeys() 方法：
Reflect.ownKeys() 方法返回一个数组，包含对象自身的所有属性的名称（包括不可枚举属性和symbol属性）。可以进一步处理这个数组来查询特定的属性。
```
const person = {
  name: 'John',
  age: 30
};

const propertyKeys = Reflect.ownKeys(person); // ['name', 'age']
const name = person[propertyKeys[0]]; // 'John'
const age = person[propertyKeys[1]]; // 30
```

- Object.defineProperty() 是 JavaScript 中用于定义对象属性的方法。它允许您精确地定义或修改对象的属性。
语法如下：
`Object.defineProperty(obj, prop, descriptor)`
参数解释：<br>
obj：要在其上定义或修改属性的对象。<br>
prop：要定义或修改的属性的名称。<br>
descriptor：定义或修改属性的描述符对象，包含以下可选的键：<br>
configurable：该属性是否可修改、删除、以及是否可以修改属性的特性，默认值为 false。<br>
enumerable：该属性是否可在遍历对象属性时被枚举，默认值为 false。<br>
value：属性的值，默认为 undefined。<br>
writable：该属性是否可被赋值运算符修改，默认为 false。<br>
get：获取属性值的函数。<br>
set：设置属性值的函数。<br>

- Object.getOwnPropertyDescriptor(obj, prop)：返回指定属性的描述符对象。
示例代码：
```
const obj = {
  name: 'John',
  age: 25
};
const descriptor = Object.getOwnPropertyDescriptor(obj, 'name');
console.log(descriptor); // 输出：{ value: 'John', writable: true, enumerable: true, configurable: true }
```

- Object.getOwnPropertySymbols(obj)：返回一个包含对象所有 Symbol 类型属性的数组。

示例代码：
```
const symbol1 = Symbol('symbol1');
const symbol2 = Symbol('symbol2');

const obj = {
  [symbol1]: 'value1',
  [symbol2]: 'value2'
};
const symbols = Object.getOwnPropertySymbols(obj);
console.log(symbols); // 输出：[symbol1, symbol2]
```

- Object.getPrototypeOf(obj)：返回指定对象的原型（即原型链中的下一个对象）。
示例代码：
```
const obj = {};
const proto = Object.getPrototypeOf(obj);
console.log(proto); // 输出：{}
```

- Object.setPrototypeOf(obj, proto)：设置一个对象的原型为指定的对象。
示例代码：
```
const obj = {};
const proto = { x: 10 };
Object.setPrototypeOf(obj, proto);
console.log(obj.x); // 输出：10
```

## 1.3 对象的拷贝 
### 1.3.1 浅拷贝
浅拷贝：<br>
使用 Object.assign(target, ...sources) 方法进行浅拷贝，将一个或多个源对象的属性复制到目标对象中。<br>
使用扩展运算符 ... 进行对象解构赋值进行浅拷贝。<br>
```
const obj = { name: 'John', age: 25 };

// 使用 Object.assign() 进行浅拷贝
const shallowCopy1 = Object.assign({}, obj);
console.log(shallowCopy1); // 输出：{ name: 'John', age: 25 }

// 使用对象解构赋值进行浅拷贝
const shallowCopy2 = { ...obj };
console.log(shallowCopy2);  // 输出：{ name: 'John', age: 25 }
```

### 1.3.2 深拷贝
- 使用 JSON 对象的 JSON.stringify() 方法将对象转换成字符串，然后使用 JSON.parse() 方法将字符串转换回对象，实现深拷贝。但该方法有限制，不能拷贝函数和循环引用。
```
const obj = { name: 'John', age: 25, hobbies: ['reading', 'sports'] };
const deepCopy = JSON.parse(JSON.stringify(obj));
console.log(deepCopy); // 输出：{ name: 'John', age: 25, hobbies: ['reading', 'sports'] }
```
- 使用递归的方式手动实现深拷贝。递归遍历对象的属性，并对每个属性进行拷贝。<br>
示例代码：
```
function deepCopy(obj) {
  if (typeof obj !== 'object' || obj === null) {
    return obj;
  }

  let result = Array.isArray(obj) ? [] : {};
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      result[key] = deepCopy(obj[key]);
    }
  }
  return result;
}
```
# 二、Array
## 2.1 创建
- 字面量方式：
```
let arr = []; // 创建一个空数组
let arr = [1, 2, 3]; // 创建一个包含几个元素的数组
let arr = ['apple', 'banana', 'orange']; // 创建一个包含字符串元素的数组
```

- 使用Array构造函数：
```
let arr = new Array(); // 创建一个空数组
let arr = new Array(1, 2, 3); // 创建一个包含几个元素的数组
let arr = new Array('apple', 'banana', 'orange'); // 创建一个包含字符串元素的数组
```

- 使用Array.from()方法：
```
let arr = Array.from([]);
let arr = Array.from([1, 2, 3]);
let arr = Array.from(['apple', 'banana', 'orange']);
```

- 使用Array.of()方法：
```
let arr = Array.of();
let arr = Array.of(1, 2, 3);
let arr = Array.of('apple', 'banana', 'orange');
```

- 借用数组方法：
```
let arr = Array.prototype.slice.call(arguments); // 将类数组对象转为真正的数组
let arr = Array.prototype.concat.apply([], arrayLike); // 合并多个数组
```

- 指定长度的数组
```
let arr=new Array(10);
```

- 数组空位
使用数组字面量初始化数组时，可以使用一串逗号来创建空位（hole）。ECMAScript 会将逗号之间相应索引位置的值当成空位，ES6 规范重新定义了该如何处理这些空位。
可以像下面这样创建一个空位数组：
```
const options = [,,,,,]; // 创建包含5 个元素的数组
console.log(options.length); // 5
console.log(options); // [,,,,,]
```

## 2.2 检测数组
一个经典的ECMAScript 问题是判断一个对象是不是数组。在只有一个网页（因而只有一个全局作
用域）的情况下，使用instanceof 操作符就足矣：
```
if (value instanceof Array){
// 操作数组
}
```

使用instanceof 的问题是假定只有一个全局执行上下文。如果网页里有多个框架，则可能涉及两个不同的全局执行上下文，因此就会有两个不同版本的Array 构造函数。
为解决这个问题，ECMAScript 提供了Array.isArray()方法。这个方法的目的就是确定一个值是否为数组，而不用管它是在哪个全局执行上下文中创建的。来看下面的例子：
```
if (Array.isArray(value)){
// 操作数组
}
```

## 2.3 迭代器方法
在ES6 中，Array 的原型上暴露了3 个用于检索数组内容的方法：keys()、values()和
entries()。keys()返回数组索引的迭代器，values()返回数组元素的迭代器，而entries()返回
索引/值对的迭代器：
```
const a = ["foo", "bar", "baz", "qux"];
// 因为这些方法都返回迭代器，所以可以将它们的内容
// 通过Array.from()直接转换为数组实例
const aKeys = Array.from(a.keys());
const aValues = Array.from(a.values());
const aEntries = Array.from(a.entries());
console.log(aKeys); // [0, 1, 2, 3]
console.log(aValues); // ["foo", "bar", "baz", "qux"]
console.log(aEntries); // [[0, "foo"], [1, "bar"], [2, "baz"], [3, "qux"]]
```

使用ES6 的解构可以非常容易地在循环中拆分键/值对：
```
const a = ["foo", "bar", "baz", "qux"];
for (const [idx, element] of a.entries()) {
alert(idx);
alert(element);
}
// 0
// foo
// 1
// bar
// 2
// baz
// 3
// qux
```

- 复制和填充方法
```
arr.fill(value, start, end)
```
参数：<br>
value：必需，要填充的值。<br>
start：可选，填充的起始索引，默认为0。如果为负数，则从末尾索引开始计算。<br>
end：可选，填充的结束索引，默认为数组长度。如果为负数，则从末尾索引开始计算。<br>
返回值：<br>
修改后的数组。<br>
```
let arr = [1, 2, 3, 4, 5];
arr.fill(0); 
// 将数组的所有元素填充为0
// 结果为 [0, 0, 0, 0, 0]

let arr2 = [1, 2, 3, 4, 5];
arr2.fill(0, 1, 3); 
// 将数组索引1到2的元素填充为0
// 结果为 [1, 0, 0, 4, 5]
```

```
arr.copyWithin(target, start, end)
```
target：必需，要将复制的元素粘贴到的目标索引。<br>
start：可选，要复制的元素的起始索引，默认为0。如果为负数，则从末尾索引开始计算。<br>
end：可选，要复制的元素的结束索引，默认为数组长度。如果为负数，则从末尾索引开始计算。<br>
返回值：<br>
复制完成后修改后的数组。<br>
```
let arr = [1, 2, 3, 4, 5];
arr.copyWithin(0, 3); 
// 将索引3及其后的元素（4, 5） 复制到索引0及以后的位置上
// 结果为 [4, 5, 3, 4, 5]

let arr2 = [1, 2, 3, 4, 5];
arr2.copyWithin(1, 2, 4); 
// 将索引2到3的元素（3, 4）复制到索引1及以后的位置上
// 结果为 [1, 3, 4, 4, 5]
```

- 转换方法
valueOf()返回的还是数组本身。而toString()返回由数组中每个值的等效字符串拼接而成的一个逗号分隔的字符串。也就是说，对数组的每个值都会调用其toString()方法，以得到最终的字符串。<br>
toLocaleString()方法也可能返回跟toString()和valueOf()相同的结果，但也不一定。在调用数组的toLocaleString()方法时，会得到一个逗号分隔的数组值的字符串。它与另外两个方法唯一的区别是，为了得到最终的字符串，会调用数组每个值的toLocaleString()方法，而不是toString()方法。

- 栈方法
```
arr.push(element1, element2, ..., elementN)
```
返回值：
被修改后的数组的新长度。

```
arr.pop()
```
返回值：
被移除的元素的值。

- 队列方法
push() 方法：将一个或多个元素添加到数组的末尾，模拟入队操作。<br>
shift() 方法：移除数组的第一个元素，并返回该元素的值，模拟出队操作。<br>
unshift() 方法：将一个或多个元素添加到数组的开头，模拟队列的前端插入操作。<br>

- 排序方法
arr.reverse();<br>
返回反序后的数组，会修改原数组<br>

arr.sort();升序<br>
```
let arr = [5, 2, 8, 1, 4];

arr.sort(function(a, b) {
  return b - a;
});

console.log(arr);
// 输出：[8, 5, 4, 2, 1]
```
降序添加排序函数

- 操作方法
1. concat()方法用于将两个或多个数组或值合并成一个新数组。它不会修改原数组，而是返回一个新的合并后的数组。
```
let arr1 = [1, 2, 3];
let arr2 = [4, 5, 6];
let arr3 = arr1.concat(arr2);
console.log(arr3);
// 输出：[1, 2, 3, 4, 5, 6]
```

concat()方法也可以用于合并数组和值：
```
let arr1 = [1, 2, 3];
let arr2 = [4, 5, 6];
let arr3 = arr1.concat(7, 8);
console.log(arr3);
// 输出：[1, 2, 3, 7, 8]
```

需要注意的是，在合并数组时，concat()方法会创建原数组的浅拷贝，所以如果原数组中包含引用类型的元素（如对象或数组），当改变原数组或新数组中的引用类型元素时，两者都会受到影响。
如果需要合并多个数组，可以在concat()方法中传入多个参数

2. slice()方法用于返回数组的一个片段或子数组，而不会修改原数组。它接受两个参数，即起始索引和结束索引（不包括），并返回一个新的数组。
```
let array = [1, 2, 3, 4, 5];
let slice1 = array.slice(1, 4);
console.log(slice1);
// 输出：[2, 3, 4]
```

如果省略第二个参数，则slice()方法将返回从起始索引到数组末尾的所有元素。

需要注意的是，slice()方法不会修改原数组，而是返回一个新的数组。这意味着可以在原数组上继续进行操作，而不影响新数组。

- 搜索和位置方法
1. 严格相等
1.1 indexOf()是JavaScript数组的一个方法，它用于返回指定元素在数组中第一次出现的索引位置，如果数组中不包含该元素，则返回-1。
```
let array = [1, 2, 3, 4, 5];
let index1 = array.indexOf(3);
console.log(index1);
// 输出：2
```

如果数组中包含多个相同的元素，indexOf()方法只返回第一个匹配的索引位置。

需要注意的是，indexOf()方法采用===运算符进行比较，这意味着它不会隐式地进行类型转换。如果要进行类型转换再进行比较，可以使用其他方法，如findIndex()。

1.2 lastIndexOf()是JavaScript数组的一个方法，它与indexOf()类似，但是它从数组的末尾开始搜索指定元素，并返回该元素最后一次出现的索引位置。

1.3 includes()是JavaScript字符串和数组的一个方法，它用于判断字符串或数组是否包含指定的元素，返回布尔值（true或false）。
```
let str = "Hello, world!";
let result1 = str.includes("world");
console.log(result1);
// 输出：true
```
```
let array = [1, 2, 3, 4, 5];
let result3 = array.includes(3);

console.log(result3);
// 输出：true
```

2. 断言函数用于检查某个条件是否满足，并在条件为假时给出警告或错误消息。它通常用于调试和验证程序中的假设。
2.1 find()是JavaScript中数组的一个方法，用于查找数组中满足指定条件的第一个元素，并返回该元素的值。如果没有符合条件的元素，则返回undefined。
find()方法接受一个回调函数作为参数，该回调函数会被依次应用于数组中的每个元素，直到找到满足条件的元素。回调函数接受三个参数：当前元素的值、当前元素的索引和原数组。回调函数应该返回一个布尔值，用于表示当前元素是否满足条件
```
const numbers = [1, 2, 3, 4, 5, 6];
const evenNumber = numbers.find(function(num) {
  return num % 2 === 0;
});
console.log(evenNumber); // 输出 2
```

```
const fruits = ['apple', 'banana', 'orange', 'pear'];
const findvalue = fruits.find(function(fruit, index, array) {
  console.log('Current fruit:', fruit);
  console.log('Current index:', index);
  console.log('Original array:', array);
  return fruit === 'orange';
});
console.log(findvalue);//输出orange
```

2.2 findIndex() 方法与 find() 方法非常相似，但它返回的是满足条件的元素的索引，而不是元素本身。
使用 findIndex() 方法时，你可以定义一个回调函数来指定条件以查找数组中的元素。回调函数可以带有三个参数：当前元素的值、当前元素的索引和原数组。

- 迭代方法
1. every() 方法用于检查数组中的所有元素是否都满足给定的条件，并返回一个布尔值。
使用 every() 方法时，你可以定义一个回调函数来指定条件以检查数组中的元素。回调函数可以带有三个参数：当前元素的值、当前元素的索引和原数组。当数组中的所有元素都满足条件时，every() 方法将返回 true，否则返回 false。

```
const numbers = [1, 2, 3, 4, 5];
const isPositive = function(number, index, array) {
  console.log('Current number:', number);
  console.log('Current index:', index);
  console.log('Original array:', array);
  return number > 0;
};
const result = numbers.every(isPositive);//true
console.log('All numbers are positive:', result);
```

2. filter() 方法用于从数组中筛选出满足条件的元素，并返回一个新的数组。
使用 filter() 方法时，你可以定义一个回调函数来指定筛选条件。回调函数可以带有三个参数：元素的值、元素的索引和原数组。当回调函数返回 true 时，该元素将被包含在新数组中；当回调函数返回 false 时，该元素将被排除在新数组之外。

```
const numbers = [1, 2, 3, 4, 5];
const isEven = function(number, index, array) {
  console.log('Current number:', number);
  console.log('Current index:', index);
  console.log('Original array:', array);
  return number % 2 === 0;
};
const evenNumbers = numbers.filter(isEven);
console.log('Even numbers:', evenNumbers);//[ 2, 4 ]
```

3. forEach() 是一个数组方法，用于遍历数组的每个元素并对其执行指定的操作。
使用 forEach() 时，你可以定义一个回调函数来定义对每个元素的操作。回调函数可以带有三个参数：元素的值、元素的索引和原数组。在遍历过程中，forEach() 方法将会依次将每个元素传递给回调函数。

4. map() 是一个数组方法，用于根据数组中的每个元素创建一个新的数组。
使用 map() 时，你可以定义一个回调函数来定义如何处理每个元素并返回一个新的值。回调函数可以带有三个参数：元素的值、元素的索引和原数组。在遍历过程中，map() 方法将会依次将每个元素传递给回调函数，并将新的返回值放入新的数组中。
```
const numbers = [1, 2, 3, 4, 5];
const doubledNumbers = numbers.map(function(number) {
  return number * 2;
});
console.log(doubledNumbers);//[2, 4, 6, 8, 10]
```

5. some() 是一个数组方法，用于检查数组中是否存在满足指定条件的元素。
使用 some() 方法时，你可以定义一个回调函数来定义满足条件的判定方式。回调函数可以带有三个参数：元素的值、元素的索引和原数组。在遍历过程中，some() 方法将会依次将每个元素传递给回调函数。
如果回调函数对任意一个元素返回 true，则 some() 方法将返回 true。如果所有元素都不满足回调函数的条件，则返回值为 false。

- 归并方法
1. reduce() 是 JavaScript 中的一个内置数组方法。它用于对数组中的所有元素进行累积计算，并返回一个单个的结果。<br>
reduce() 方法接受一个回调函数作为参数，这个回调函数可以带有四个参数：<br>
累积值（accumulator）：在每次迭代中累积计算的结果。<br>
当前值（currentValue）：当前正在处理的元素值。<br>
当前索引（currentIndex）：当前正在处理的元素索引。<br>
原数组（array）：正在被遍历的原数组。<br>

回调函数通过操作累积值和当前值来达到计算的目的，并将最终的结果返回。在每次迭代中，累积值将被更新，并被传递给下一次迭代。
reduce() 方法还接受一个可选的初始值参数。如果提供了初始值，则累积值将从初始值开始累积计算；如果未提供初始值，则累积值将从数组的第一个元素开始计算。
```
const numbers = [1, 2, 3, 4, 5];
const sum = numbers.reduce(function(accumulator, currentValue) {
  return accumulator + currentValue;
}, 0);
console.log(sum); // 输出 15
```
2. reduceRight() reduceRight()方法与reduce()类似，只是方向相反
