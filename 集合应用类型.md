# 一、object
## 1.1 创建
- 对象字面量（Object Literal）：
这是最简单的创建对象的方式，可以直接使用花括号 {} 创建一个对象，并通过属性和值的键值对来定义对象的属性和方法
```
const person = {
  name: 'John',
  age: 30,
  sayHello: function() {
    console.log('Hello!');
  }
};
```
- 构造函数（Constructor）：
可以使用构造函数创建一个对象，使用 new 关键字调用构造函数来创建对象的实例。构造函数内可以定义对象的属性和方法。
```
function Person(name, age) {
  this.name = name;
  this.age = age;
  this.sayHello = function() {
    console.log('Hello!');
  };
}

const person = new Person('John', 30);
```
- Object.create() 方法：
可以使用 Object.create() 方法创建一个新对象，并指定新对象的原型对象。原型对象可以包含对象的属性和方法。
```
const personPrototype = {
  sayHello: function() {
    console.log('Hello!');
  }
};

const person = Object.create(personPrototype);
person.name = 'John';
person.age = 30;

```
- 类（ES6+）：
可以使用类（class）来创建对象，并定义类的构造函数、属性和方法。类的实例化使用 new 关键字。
```
class Person {
  constructor(name, age) {
    this.name = name;
    this.age = age;
  }

  sayHello() {
    console.log('Hello!');
  }
}

const person = new Person('John', 30);
```
## 1.2 属性查询
- 点记法（Dot Notation）：
使用点号 . 后接属性名的方式，可以直接从对象上查询指定的属性。适用于属性名是有效的标识符的情况。
```
const person = {
  name: 'John',
  age: 30
};

const name = person.name; // 'John'
const age = person.age; // 30
```

- 方括号记法（Bracket Notation）：
使用方括号 [] 内包裹属性名的方式，可以从对象上查询指定的属性。适用于属性名包含特殊字符、动态生成的情况,方括号内应为字符串。
```
const person = {
  'first name': 'John',
  age: 30
};

const firstName = person['first name']; // 'John'
const age = person['age']; // 30
```

- Object.keys() 方法：
当想获取对象中所有可枚举属性的名称时，可以使用 Object.keys() 方法返回一个包含对象自身的所有属性名的数组。可以进一步处理这个数组来查询特定的属性。
```
const person = {
  name: 'John',
  age: 30
};
const keys = Object.keys(person); // ['name', 'age']
const name = person[keys[0]]; // 'John'
const age = person[keys[1]]; // 30
```

- Object.values(obj)：返回一个包含对象所有可枚举属性的值的数组。
示例代码：
```
const obj = {
  name: 'John',
  age: 25
};
const values = Object.values(obj);
console.log(values); // 输出：['John', 25]
```

- Object.entries(obj)：返回一个包含对象所有可枚举属性的键值对数组。
示例代码：
```
const obj = {
  name: 'John',
  age: 25
};
const entries = Object.entries(obj);
console.log(entries); // 输出：[['name', 'John'], ['age', 25]]
```

- in 操作符：
使用 in 操作符可以检查对象中是否存在指定的属性，返回布尔值结果。
```
const person = {
  name: 'John',
  age: 30
};
const hasName = 'name' in person; // true
const hasGender = 'gender' in person; // false
```

- hasOwnProperty() 方法：
使用 hasOwnProperty() 方法可以检查对象是否具有指定的属性。该方法只会检查对象自身是否拥有该属性，不会检查原型链上的属性。
```
const person = {
  name: 'John',
  age: 30
};
const hasName = person.hasOwnProperty('name'); // true
const hasGender = person.hasOwnProperty('gender'); // false
```

- Object.getOwnPropertyNames() 方法：
Object.getOwnPropertyNames() 方法返回一个数组，包含对象自身的所有属性（包括不可枚举属性,不包括symbol属性）的名称。可以进一步处理这个数组来查询特定的属性。
```
const person = {
  name: 'John',
  age: 30
};
const propertyNames = Object.getOwnPropertyNames(person); // ['name', 'age']
const name = person[propertyNames[0]]; // 'John'
const age = person[propertyNames[1]]; // 30
```

- Reflect.ownKeys() 方法：
Reflect.ownKeys() 方法返回一个数组，包含对象自身的所有属性的名称（包括不可枚举属性和symbol属性）。可以进一步处理这个数组来查询特定的属性。
```
const person = {
  name: 'John',
  age: 30
};

const propertyKeys = Reflect.ownKeys(person); // ['name', 'age']
const name = person[propertyKeys[0]]; // 'John'
const age = person[propertyKeys[1]]; // 30
```

- Object.defineProperty() 是 JavaScript 中用于定义对象属性的方法。它允许您精确地定义或修改对象的属性。
语法如下：
`Object.defineProperty(obj, prop, descriptor)`
参数解释：<br>
obj：要在其上定义或修改属性的对象。<br>
prop：要定义或修改的属性的名称。<br>
descriptor：定义或修改属性的描述符对象，包含以下可选的键：<br>
configurable：该属性是否可修改、删除、以及是否可以修改属性的特性，默认值为 false。<br>
enumerable：该属性是否可在遍历对象属性时被枚举，默认值为 false。<br>
value：属性的值，默认为 undefined。<br>
writable：该属性是否可被赋值运算符修改，默认为 false。<br>
get：获取属性值的函数。<br>
set：设置属性值的函数。<br>

- Object.getOwnPropertyDescriptor(obj, prop)：返回指定属性的描述符对象。
示例代码：
```
const obj = {
  name: 'John',
  age: 25
};
const descriptor = Object.getOwnPropertyDescriptor(obj, 'name');
console.log(descriptor); // 输出：{ value: 'John', writable: true, enumerable: true, configurable: true }
```

- Object.getOwnPropertySymbols(obj)：返回一个包含对象所有 Symbol 类型属性的数组。

示例代码：
```
const symbol1 = Symbol('symbol1');
const symbol2 = Symbol('symbol2');

const obj = {
  [symbol1]: 'value1',
  [symbol2]: 'value2'
};
const symbols = Object.getOwnPropertySymbols(obj);
console.log(symbols); // 输出：[symbol1, symbol2]
```

- Object.getPrototypeOf(obj)：返回指定对象的原型（即原型链中的下一个对象）。
示例代码：
```
const obj = {};
const proto = Object.getPrototypeOf(obj);
console.log(proto); // 输出：{}
```

- Object.setPrototypeOf(obj, proto)：设置一个对象的原型为指定的对象。
示例代码：
```
const obj = {};
const proto = { x: 10 };
Object.setPrototypeOf(obj, proto);
console.log(obj.x); // 输出：10
```

## 1.3 对象的拷贝 
### 1.3.1 浅拷贝
浅拷贝：<br>
使用 Object.assign(target, ...sources) 方法进行浅拷贝，将一个或多个源对象的属性复制到目标对象中。<br>
使用扩展运算符 ... 进行对象解构赋值进行浅拷贝。<br>
```
const obj = { name: 'John', age: 25 };

// 使用 Object.assign() 进行浅拷贝
const shallowCopy1 = Object.assign({}, obj);
console.log(shallowCopy1); // 输出：{ name: 'John', age: 25 }

// 使用对象解构赋值进行浅拷贝
const shallowCopy2 = { ...obj };
console.log(shallowCopy2);  // 输出：{ name: 'John', age: 25 }
```

### 1.3.2 深拷贝
- 使用 JSON 对象的 JSON.stringify() 方法将对象转换成字符串，然后使用 JSON.parse() 方法将字符串转换回对象，实现深拷贝。但该方法有限制，不能拷贝函数和循环引用。
```
const obj = { name: 'John', age: 25, hobbies: ['reading', 'sports'] };
const deepCopy = JSON.parse(JSON.stringify(obj));
console.log(deepCopy); // 输出：{ name: 'John', age: 25, hobbies: ['reading', 'sports'] }
```
- 使用递归的方式手动实现深拷贝。递归遍历对象的属性，并对每个属性进行拷贝。<br>
示例代码：
```
function deepCopy(obj) {
  if (typeof obj !== 'object' || obj === null) {
    return obj;
  }

  let result = Array.isArray(obj) ? [] : {};
  for (let key in obj) {
    if (obj.hasOwnProperty(key)) {
      result[key] = deepCopy(obj[key]);
    }
  }
  return result;
}
```
